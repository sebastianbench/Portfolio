<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sebastian Echavarria</title>
  <style>

    /* 1) Make every element use border-box so borders don't add to width */
*, *::before, *::after {
  box-sizing: border-box;
}

// Pie Chart drawing function
function drawPieChart() {
  const canvas = document.getElementById('pieChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('pieTooltip');
  
  // Force clear any existing event listeners
  canvas.replaceWith(canvas.cloneNode(true));
  const newCanvas = document.getElementById('pieChart');
  const newCtx = newCanvas.getContext('2d');
  
  // Set canvas size
  const rect = newCanvas.getBoundingClientRect();
  newCanvas.width = rect.width * window.devicePixelRatio;
  newCanvas.height = rect.height * window.devicePixelRatio;
  newCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Clear canvas completely - use bright color to test
  newCtx.fillStyle = '#0a0a0a';
  newCtx.fillRect(0, 0, width, height);
  
  // Calculate center and radius
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) * 0.35;
  const innerRadius = radius * 0.95;
  
  // Just draw the donut - NO TEXT ANYWHERE
  const greyAngle = (99 / 100) * 2 * Math.PI;
  
  // Draw grey segment (99% - Organic Traffic)
  newCtx.beginPath();
  newCtx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + greyAngle);
  newCtx.arc(centerX, centerY, innerRadius, -Math.PI / 2 + greyAngle, -Math.PI / 2, true);
  newCtx.closePath();
  newCtx.fillStyle = '#323131';
  newCtx.fill();
  
  // Draw red segment (1% - Paid Advertising)
  newCtx.beginPath();
  newCtx.arc(centerX, centerY, radius, -Math.PI / 2 + greyAngle, -Math.PI / 2 + 2 * Math.PI);
  newCtx.arc(centerX, centerY, innerRadius, -Math.PI / 2 + 2 * Math.PI, -Math.PI / 2 + greyAngle, true);
  newCtx.closePath();
  newCtx.fillStyle = '#880423';
  newCtx.fill();
  
  // Mouse hover functionality
  newCanvas.addEventListener('mousemove', (e) => {
    const rect = newCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const distanceFromCenter = Math.sqrt((mouseX - centerX) ** 2 + (mouseY - centerY) ** 2);
    
    if (distanceFromCenter >= innerRadius && distanceFromCenter <= radius) {
      const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
      const normalizedAngle = angle < -Math.PI / 2 ? angle + 2 * Math.PI : angle;
      
      let hoveredSegment = null;
      
      // Check if hovering over grey segment (organic traffic)
      if (normalizedAngle >= -Math.PI / 2 + 2 * Math.PI && normalizedAngle <= -Math.PI / 2 + 2 * Math.PI + greyAngle) {
        hoveredSegment = {
          label: 'Organic Traffic',
          color: '#323131'
        };
      }
      // Check if hovering over red segment (paid advertising)  
      else if (normalizedAngle >= -Math.PI / 2 + 2 * Math.PI + greyAngle || normalizedAngle <= -Math.PI / 2 + 2 * Math.PI) {
        hoveredSegment = {
          label: 'Paid Advertising',
          color: '#880423'
        };
      }
      
      if (hoveredSegment) {
        const containerRect = newCanvas.closest('.chart-container').getBoundingClientRect();
        const relativeX = e.clientX - containerRect.left;
        const relativeY = e.clientY - containerRect.top;
        
        const tooltipWidth = 200;
        const tooltipHeight = 100;
        let leftPos = relativeX - 15;
        let topPos = relativeY - 120;
        
        if (leftPos + tooltipWidth > containerRect.width) {
          leftPos = containerRect.width - tooltipWidth - 10;
        }
        if (leftPos < 10) {
          leftPos = 10;
        }
        
        if (topPos < 10) {
          topPos = relativeY + 20;
        }
        if (topPos + tooltipHeight > containerRect.height) {
          topPos = containerRect.height - tooltipHeight - 10;
        }
        
        tooltip.style.display = 'block';
        tooltip.style.left = leftPos + 'px';
        tooltip.style.top = topPos + 'px';
        tooltip.innerHTML = `
          <div class="tooltip-platform" style="color: ${hoveredSegment.color};">
            <div class="tooltip-circle" style="background-color: ${hoveredSegment.color};"></div>
            ${hoveredSegment.label}
          </div>
          <div class="tooltip-value">0% spent on ads</div>
          <div class="tooltip-growth">Pure organic growth</div>
        `;
        
        if (window.pieTooltipTimeout) {
          clearTimeout(window.pieTooltipTimeout);
        }
      } else {
        if (window.pieTooltipTimeout) {
          clearTimeout(window.pieTooltipTimeout);
        }
        window.pieTooltipTimeout = setTimeout(() => {
          tooltip.style.display = 'none';
        }, 300);
      }
    } else {
      if (window.pieTooltipTimeout) {
        clearTimeout(window.pieTooltipTimeout);
      }
      window.pieTooltipTimeout = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  newCanvas.addEventListener('mouseleave', () => {
    if (window.pieTooltipTimeout) {
      clearTimeout(window.pieTooltipTimeout);
    }
    window.pieTooltipTimeout = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

/* 2) (Re-)define your container with a border */
.container {
  /* no more white outline */
  border: none;

  /* shrink to 800px so there's less dead space */
  max-width: 800px;
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
}

    
    /* Typography Hierarchy */
.bold {
  font-family: 'Manrope', sans-serif;
  font-weight: 700;
}

/* H1 - Hero title (keep current size) */
.hero p {
  font-size: 35px; /* Keep as is */
  margin: 0.2rem 0;
}

/* HERO TEXT REVEAL ANIMATION */
.hero p {
  opacity: 0;
  filter: blur(10px);
  transform: translateY(20px);
  animation-fill-mode: forwards;
}

.hero p:nth-child(1) {
  animation: textReveal 1s ease-out 0.5s forwards;
}

.hero p:nth-child(2) {
  animation: textReveal 1s ease-out 1.5s forwards;
}

.hero p:nth-child(3) {
  animation: textReveal 1s ease-out 2.5s forwards;
}

@keyframes textReveal {
  0% {
    opacity: 0;
    filter: blur(10px);
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    filter: blur(0);
    transform: translateY(0);
  }
}

/* H2 - Marketing Manager in main content */
.left-column p .bold {
  font-size: 28px; /* ~80% of H1 */
}

/* H3 - Company name and location in main content */
.left-column p .extralight {
  font-size: 21px; /* ~60% of H1 */
  display: block;
}

/* Paragraph - List items in main content */
.left-column ul li {
  font-size: 16px; /* ~45% of H1 */
}
    
/* — Web-fonts — */
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-ExtraLight.woff') format('woff'),
       url('../fonts/Manrope-ExtraLight.ttf')  format('truetype');
  font-weight: 200;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-Regular.woff') format('woff'),
       url('../fonts/Manrope-Regular.ttf')  format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-Bold.woff') format('woff'),
       url('../fonts/Manrope-Bold.ttf')  format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

.extralight {
  font-family: 'Manrope', sans-serif;
  font-weight: 200;
}

    
    body {
      margin: 0;
      font-family: 'Manrope', sans-serif;
      background-color: #111;
      color: #fff;
      overflow-x: hidden; /* Prevent horizontal scroll during animations */
    }

    /* SCROLL ANIMATIONS */
    .fade-in {
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .slide-in-left {
      opacity: 0;
      transform: translateX(-50px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .slide-in-left.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .slide-in-right {
      opacity: 0;
      transform: translateX(50px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .slide-in-right.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .scale-in {
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .scale-in.visible {
      opacity: 1;
      transform: scale(1);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      margin: 0 auto;
    }

    .avatar {
      border-radius: 50%;
      width: 40px;
      height: 40px;
    }

    .nav-links {
      list-style: none;
      display: flex;
      gap: 1rem;
    }

    .nav-links li a {
      text-decoration: none;
      padding: 0.5rem 1rem;
      background: #222;
      color: #fff;
      border-radius: 8px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .nav-links li a.cta {
      background: #fff;
      color: #111;
      font-weight: 600;
    }

    .nav-links li a:hover {
      background: #333;
    }

    .hero {
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 2rem 1.5rem;  /* More generous padding */
      text-align: left;
      margin: 2rem auto 1rem;  /* Better spacing around hero */
    }

    .hero p {
      font-size: 35px;
      margin: 0.2rem 0;
    }

    .hero p span.bold {
      font-weight: 700;
    }

    .hero p span.light {
      font-weight: 100;
    }

    .content-section {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      padding: 3rem 1.5rem;  /* More generous padding */
      gap: 3rem;  /* More space between columns */
      margin: 0 auto;
    }

    .left-column, .right-column {
      flex: 1 1 45%;
    }

    .left-column img {
      width: 60px;
      margin-bottom: 1.5rem;  /* More space after logo */
    }

    .left-column p {
      font-size: 20px;
      line-height: 1.6;
      margin: 0 0 1.5rem;  /* More space after title block */
    }

    .left-column ul {
      margin-top: 0;
      padding-left: 1.5rem;
      margin-bottom: 4rem;  /* Keep existing bottom spacing */
    }

    .left-column ul li {
      font-size: 16px;
      line-height: 1.7;  /* Better line spacing */
      margin-bottom: 8px;  /* Space between list items */
    }

    .right-column img {
      width: 100%;
      max-width: 800px;  /* Much bigger max width */
      border-radius: 20px;
    }

/* Remove the extra top-margin on the list */
.left-column ul {
  margin-top: 0;
}

    .left-column p {
  margin: 0 0 1rem;
}

   

/* Make the container fluid up to 1200px */
.container {
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
}

/* Responsive two-column content */
.content-section {
  display: flex;
  flex-wrap: wrap;
  gap: 2rem;
}

.content-section > div {
  /* Two columns side by side on desktop */
  flex: 1 1 calc(50% - 2rem);
}



/* Fluid right-column image, no overflow */
.right-column img {
  width: 100%;
  max-width: 800px;  /* Much bigger and responsive */
  border-radius: 20px;
}
  

/* FIXED GALLERY SECTION */
.gallery {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 40px;  /* More breathing room */
  width: 100%;
  max-width: 1800px;
  margin: 80px auto 100px;  /* More space above and below */
  padding: 0 3rem;
  box-sizing: border-box;
}

.gallery-item {
  display: flex;
  flex-direction: column;
  gap: 25px;  /* More space between image and text */
  position: relative;
  z-index: 1;  /* Lower z-index for gallery items */
}

/* Chart container styling */
.chart-container {
  width: 100%;
  height: 400px;
  background-color: #0a0a0a;
  border-radius: 15px;
  padding: 15px;  /* Restore some padding for proper spacing */
  box-sizing: border-box;
  position: relative;
  transition: transform 0.3s ease;
  overflow: visible;  /* Allow tooltip to show outside if needed */
}

/* Mobile adjustments for chart */
@media (max-width: 768px) {
  .chart-container {
    padding: 10px;  /* Minimal but some padding for mobile */
    margin: 0;      /* Remove any extra margins */
  }
}

.chart-container:hover {
  transform: scale(1.02);
}

.chart-title {
  font-family: 'Manrope', sans-serif;
  font-weight: 700;
  font-size: 18px;
  color: #fff;
  text-align: center;
  margin-bottom: 20px;
}

.chart-canvas {
  width: 100%;
  height: 100%;  /* Use full container height now */
}

/* Tooltip styling */
.chart-tooltip {
  position: absolute !important;  /* Absolute positioning relative to chart container */
  background-color: rgba(0, 0, 0, 0.95);
  border: 1px solid #444;
  border-radius: 12px;
  padding: 16px;
  font-family: 'Manrope', sans-serif;
  color: #fff;
  pointer-events: none;
  z-index: 100;  /* High within the chart container */
  display: none;
  min-width: 200px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.tooltip-platform {
  font-size: 14px;
  font-weight: 700;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
}

.tooltip-circle {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.tooltip-value {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 4px;
}

.tooltip-growth {
  font-size: 12px;
  font-weight: 600;
  color: #4ade80;
}

.tooltip-year {
  font-size: 12px;
  color: #888;
  margin-top: 8px;
}

.gallery-item img {
  width: 100%;
  height: 400px;
  object-fit: contain;  /* Show full image, no cropping */
  object-position: center;
  border-radius: 15px;
  transition: transform 0.3s ease;
  background-color: #1a1a1a;  /* Dark background for letterboxing if needed */
  position: relative;
  z-index: 1;  /* Lower z-index for images */
}

.gallery-item img:hover {
  transform: scale(1.02);
}

.gallery-caption p {
  font-size: 16px;
  line-height: 1.6;  /* Better line spacing */
  margin: 0 0 20px 0;  /* Space below title */
}

/* H3 - Gallery titles */
.gallery-caption .bold {
  font-size: 21px;
}

.gallery-caption .extralight {
  font-size: 21px;
  display: block;
  margin-bottom: 10px;
}

.gallery-caption ul {
  margin: 0;
  padding-left: 1.5rem;
}

/* Paragraph - Gallery list items */
.gallery-caption ul li {
  font-size: 16px;
  line-height: 1.6;  /* Better line spacing */
  margin-bottom: 10px;  /* More space between list items */
}

/* Tablet view - Better responsive handling */
@media (max-width: 1200px) and (min-width: 769px) {
  .gallery {
    grid-template-columns: 1fr 1fr;
    max-width: 95%;
    gap: 25px;
    margin: 60px auto 80px;
    padding: 0 2rem;
  }
  
  .gallery-item {
    gap: 20px;
  }
  
  .gallery-item img {
    height: 320px;
    object-fit: contain;
  }
  
  .gallery-caption p {
    margin-bottom: 15px;
  }
}

/* Large tablet view */
@media (max-width: 1024px) and (min-width: 901px) {
  .gallery {
    grid-template-columns: repeat(3, 1fr);
    max-width: 98%;
    gap: 20px;
  }
  
  .gallery-item img {
    height: 280px;
    object-fit: contain;
  }
}

/* Medium tablet */
@media (max-width: 900px) and (min-width: 769px) {
  .gallery {
    grid-template-columns: 1fr 1fr;
    max-width: 90%;
    gap: 30px;
  }
  
  .gallery-item img {
    height: 300px;
    object-fit: contain;
  }
}

/* Mobile view - Much more generous spacing */
@media (max-width: 768px) {
  .gallery {
    grid-template-columns: 1fr;
    max-width: 100%;
    padding: 0 1rem;  /* Add padding back on mobile for text breathing room */
    margin: 50px auto 60px;  /* Generous vertical margins */
    gap: 50px;  /* Much more space between items */
  }
  
  .gallery-item {
    gap: 30px;  /* More space between image and text */
  }
  
  .gallery-item img {
    height: 250px;  /* Good size for mobile */
    object-fit: contain;  /* Show full image on mobile too */
  }
  
  .gallery-caption p {
    margin-bottom: 20px;  /* More space below title */
  }
  
  .gallery-caption ul li {
    margin-bottom: 12px;  /* More space between bullet points */
    line-height: 1.7;  /* Even better line spacing on mobile */
  }
}

/* Force all text to white */
body {
  color: #fff !important;
}

  @media (max-width: 768px) {
  /* Hero section - more breathing room */
  .hero {
    padding: 2.5rem 1rem;
    margin: 1.5rem auto 2rem;
  }

  /* Content section - better mobile spacing */
  .content-section {
    display: flex;
    flex-direction: column;
    gap: 0;
    padding: 2rem 1rem;  /* More generous mobile padding */
  }

  .content-section .right-column {
    order: -1;
    margin: 0 0 2rem;  /* Clean spacing below image */
  }

  .content-section .left-column {
    margin: 0;
  }

  .content-section .left-column img {
    margin-bottom: 2rem;  /* More space after logo */
  }

  .content-section .left-column p {
    margin-bottom: 2rem;  /* More space after title block */
  }

  .content-section .left-column ul {
    margin-bottom: 3rem;  /* Space before gallery */
  }

  .content-section .left-column ul li {
    margin-bottom: 10px;  /* More space between mobile list items */
    line-height: 1.8;  /* Better line spacing on mobile */
  }

  .content-section .right-column img {
    margin: 0;
  }

  /* Container adjustments */
  .container {
    max-width: none;
    width: 100%;
    padding: 0;
    margin: 0;
  }

  /* Navigation and sections */
  .nav,
  .hero,
  .content-section {
    width: 100%;
    margin: 0 auto;
  }

  /* Navigation spacing */
  .nav {
    margin: 2rem 0 !important;
    padding: 0 1rem;
  }
}

    /* 5) Add vertical breathing room around the nav */
.nav {
    margin: 1.5rem 0 !important;
  }

/* 6) Push the hero text down from the top */
.hero {
  margin-top: 2rem;  /* 3rem above "Sebastian …" */
}


/* 3rem space after the left-column text block */
.left-column ul {
  margin-bottom: 3rem;
}


    
  </style>
</head>
<body>

  
  <div class="container">

  
  <header>
    <nav class="nav fade-in">
      <div class="logo">
        <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Cover%20image%20CV4.png?raw=true" alt="Profile" class="avatar" />
      </div>
      <ul class="nav-links">
  <li><a href="#" class="cta">Contact</a></li>
</ul>

    </nav>
    <div class="hero">
      <p><span class="bold">Sebastian Echavarria.</span></p>
<p><span class="bold">Marketing</span> <span class="extralight">Manager.</span></p>
<p><span class="bold">Creative</span> <span class="extralight">Director.</span></p>
    </div>
  </header>
  <section class="content-section">
    <div class="left-column slide-in-left">
      <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/rbm_logov2.png?raw=true" alt="RBM Logo">
       <p>
      <span class="bold">Marketing Manager.</span><br>
      <span class="extralight">
        Red Bow Music.<br>
        Bremen, Germany.
      </span>
    </p>
    <ul>
      <li>Founder of a company.</li>
      <li>1000 orders in the first year.</li>
      <li>9000+ orders since.</li>
    </ul>
  </div>
  <div class="right-column slide-in-right">
    <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Iphone%20RBM%2004.jpg?raw=true"
         alt="Phone Preview">
  </div>
</section>
    </div>

<section class="gallery">
  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="growthChart"></canvas>
      <div class="chart-tooltip" id="chartTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Fast Growth.</span><br />
      </p>
      <ul>
        <li>Grew by 100% in the 2nd year</li>
        <li>Over 2 Mio. likes in the 5th year</li>
        <li>Completely organic, no ads</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="revenueChart"></canvas>
      <div class="chart-tooltip" id="revenueTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Reliable Results.</span><br />
      </p>
      <ul>
        <li>Consistent positive results</li>
        <li>1000+ orders per year</li>
        <li>Slowly increasing income</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="pieChart"></canvas>
      <div class="chart-tooltip" id="pieTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Reliable Results.</span><br />
      </p>
      <ul>
        <li>Consistent positive results</li>
        <li>1000+ orders per year</li>
        <li>Slowly increasing income</li>
      </ul>
    </div>
  </div>
</section>


<script>
// Scroll animation observer
const observerOptions = {
  threshold: 0.1,
  rootMargin: '0px 0px -50px 0px'
};

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    }
  });
}, observerOptions);

// Pie Chart Data
const pieData = {
  labels: ['Organic', 'Paid'],
  data: [99, 1],
  colors: ['#323131', '#880423']
};

// Revenue Chart Data
const revenueData = {
  labels: ["'20", "'21", "'22", "'23", "'24", "'25"],
  data: [0.05, 0.1, 2, 10, 22, 30],
  colors: ['#323131', '#323131', '#323131', '#323131', '#323131', '#880423']  // Updated grey color
};

// Growth Chart Data
const chartData = {
  labels: ["'20", "'21", "'22", "'23", "'24", "'25"],
  datasets: [
    {
      label: 'YouTube',
      data: [1000, 3000, 6000, 25000, 55000, 130000],
      color: '#8a0324'
    },
    {
      label: 'TikTok', 
      data: [3000, 7000, 10000, 30000, 65000, 95000],
      color: '#c1123d'
    },
    {
      label: 'Instagram',
      data: [500, 600, 1500, 15000, 55000, 85000],
      color: '#ff406f'
    }
  ]
};

// Revenue Bar Chart drawing function
function drawRevenueChart(canvasId = 'revenueChart', tooltipId = 'revenueTooltip') {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Chart margins
  const margin = { top: 40, right: 5, bottom: 60, left: 60 };  
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  
  // Adjust margins for smaller screens
  if (width < 768) {
    margin.top = 30;  
    margin.right = 2;   
    margin.bottom = 40;  
    margin.left = 45;   
  }
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Find max value for scaling
  const maxValue = Math.max(...revenueData.data);
  const scale = chartHeight / maxValue;
  
  // Draw axes
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  // Y-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  
  // X-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Y-axis labels
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (chartHeight * i / 5);
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'right';
    const value = Math.round(maxValue * (5 - i) / 5);
    const formattedValue = value >= 1 ? value + 'k €' : (value * 1000) + ' €';
    ctx.fillText(formattedValue, margin.left - 10, y + 4);
  }
  
  // Draw bars with rounded tops
  const barWidth = chartWidth / revenueData.data.length * 0.6; // 60% width with spacing
  const barSpacing = chartWidth / revenueData.data.length;
  const borderRadius = 8; // Radius for rounded tops
  
  revenueData.data.forEach((value, i) => {
    const barHeight = value * scale;
    const x = margin.left + (barSpacing * i) + (barSpacing - barWidth) / 2;
    const y = margin.top + chartHeight - barHeight;
    
    // Draw bar with rounded top
    ctx.fillStyle = revenueData.colors[i];
    ctx.beginPath();
    
    if (barHeight > borderRadius) {
      // Rectangle body
      ctx.rect(x, y + borderRadius, barWidth, barHeight - borderRadius);
      // Rounded top
      ctx.moveTo(x, y + borderRadius);
      ctx.arcTo(x, y, x + borderRadius, y, borderRadius);
      ctx.lineTo(x + barWidth - borderRadius, y);
      ctx.arcTo(x + barWidth, y, x + barWidth, y + borderRadius, borderRadius);
      ctx.lineTo(x + barWidth, y + barHeight);
      ctx.lineTo(x, y + barHeight);
      ctx.closePath();
    } else {
      // For very small bars, just draw a rounded rectangle
      ctx.roundRect(x, y, barWidth, barHeight, [borderRadius, borderRadius, 0, 0]);
    }
    
    ctx.fill();
    
    // X-axis labels
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(revenueData.labels[i], x + barWidth/2, height - margin.bottom + 20);
  });
  
  // Mouse hover functionality for bars
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    let hoveredBar = null;
    
    revenueData.data.forEach((value, i) => {
      const barHeight = value * scale;
      const x = margin.left + (barSpacing * i) + (barSpacing - barWidth) / 2;
      const y = margin.top + chartHeight - barHeight;
      
      // Check if mouse is over this bar
      if (mouseX >= x && mouseX <= x + barWidth && mouseY >= y && mouseY <= y + barHeight) {
        const prevValue = i > 0 ? revenueData.data[i-1] : revenueData.data[i];
        const growthPercent = i > 0 ? (((value - prevValue) / prevValue) * 100).toFixed(1) : 0;
        
        hoveredBar = {
          year: revenueData.labels[i],
          value: value,
          formattedValue: value >= 1 ? value + 'k €' : (value * 1000) + ' €',
          growth: growthPercent,
          color: revenueData.colors[i],
          x: e.clientX,
          y: e.clientY
        };
      }
    });
    
    if (hoveredBar) {
      const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
      const relativeX = hoveredBar.x - containerRect.left;
      const relativeY = hoveredBar.y - containerRect.top;
      
      const tooltipWidth = 200;
      const tooltipHeight = 120;
      let leftPos = relativeX - 15;
      let topPos = relativeY - 140;
      
      // Keep tooltip within chart container bounds
      if (leftPos + tooltipWidth > containerRect.width) {
        leftPos = containerRect.width - tooltipWidth - 10;
      }
      if (leftPos < 10) {
        leftPos = 10;
      }
      
      if (topPos < 10) {
        topPos = relativeY + 20;
      }
      if (topPos + tooltipHeight > containerRect.height) {
        topPos = containerRect.height - tooltipHeight - 10;
      }
      
      tooltip.style.display = 'block';
      tooltip.style.left = leftPos + 'px';
      tooltip.style.top = topPos + 'px';
      tooltip.innerHTML = `
        <div class="tooltip-platform" style="color: ${hoveredBar.color};">
          <div class="tooltip-circle" style="background-color: ${hoveredBar.color};"></div>
          Revenue
        </div>
        <div class="tooltip-value">${hoveredBar.formattedValue}</div>
        <div class="tooltip-growth">+${hoveredBar.growth}% vs previous year</div>
        <div class="tooltip-year">${hoveredBar.year}</div>
      `;
      
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
    } else {
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
      window[timeoutKey] = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    const timeoutKey = `${canvasId}TooltipTimeout`;
    if (window[timeoutKey]) {
      clearTimeout(window[timeoutKey]);
    }
    window[timeoutKey] = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

// Pie Chart drawing function
function drawPieChart() {
  const canvas = document.getElementById('pieChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('pieTooltip');
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Calculate center and radius
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) * 0.35; // Outer radius
  const innerRadius = radius * 0.5; // Inner radius for donut effect
  
  // Calculate angles
  let currentAngle = -Math.PI / 2; // Start at top
  const segments = [];
  
  pieData.data.forEach((value, i) => {
    const sliceAngle = (value / 100) * 2 * Math.PI;
    
    segments.push({
      startAngle: currentAngle,
      endAngle: currentAngle + sliceAngle,
      value: value,
      label: pieData.labels[i],
      color: pieData.colors[i]
    });
    
    currentAngle += sliceAngle;
  });
  
  // Draw segments
  segments.forEach(segment => {
    // Draw outer arc
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, segment.startAngle, segment.endAngle);
    ctx.arc(centerX, centerY, innerRadius, segment.endAngle, segment.startAngle, true);
    ctx.closePath();
    ctx.fillStyle = segment.color;
    ctx.fill();
  });
  
// ⬇️ ADD LEGEND HERE (top)
// Responsive top legend
let legendX = 20;
let legendY = 20;
const maxLegendWidth = width - 40; // 20px padding on both sides

segments.forEach((segment, i) => {
  const labelText = `${segment.label} (${segment.value}%)`;
  const textWidth = ctx.measureText(labelText).width;
  const itemWidth = textWidth + 32; // box + spacing

  // Wrap to next line if too wide
  if (legendX + itemWidth > maxLegendWidth) {
    legendX = 20;
    legendY += 24;
  }

  // Draw color box
  ctx.fillStyle = segment.color;
  ctx.fillRect(legendX, legendY, 12, 12);

  // Draw label text
  ctx.fillStyle = '#fff';
  ctx.font = '12px Manrope, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(labelText, legendX + 18, legendY + 10);

  // Move to next item position
  legendX += itemWidth;
});

  
  // Mouse hover functionality
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Check if mouse is over any segment
    const distanceFromCenter = Math.sqrt((mouseX - centerX) ** 2 + (mouseY - centerY) ** 2);
    
    if (distanceFromCenter >= innerRadius && distanceFromCenter <= radius) {
      // Calculate angle from center to mouse
      const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
      const normalizedAngle = angle < -Math.PI / 2 ? angle + 2 * Math.PI : angle;
      
      // Find which segment the mouse is over
      const hoveredSegment = segments.find(segment => {
        let startAngle = segment.startAngle;
        let endAngle = segment.endAngle;
        
        // Normalize angles for comparison
        if (startAngle < -Math.PI / 2) startAngle += 2 * Math.PI;
        if (endAngle < -Math.PI / 2) endAngle += 2 * Math.PI;
        
        return normalizedAngle >= startAngle && normalizedAngle <= endAngle;
      });
      
      if (hoveredSegment) {
        const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
        const relativeX = e.clientX - containerRect.left;
        const relativeY = e.clientY - containerRect.top;
        
        const tooltipWidth = 200;
        const tooltipHeight = 100;
        let leftPos = relativeX - 15;
        let topPos = relativeY - 120;
        
        // Keep tooltip within chart container bounds
        if (leftPos + tooltipWidth > containerRect.width) {
          leftPos = containerRect.width - tooltipWidth - 10;
        }
        if (leftPos < 10) {
          leftPos = 10;
        }
        
        if (topPos < 10) {
          topPos = relativeY + 20;
        }
        if (topPos + tooltipHeight > containerRect.height) {
          topPos = containerRect.height - tooltipHeight - 10;
        }
        
        tooltip.style.display = 'block';
        tooltip.style.left = leftPos + 'px';
        tooltip.style.top = topPos + 'px';
        tooltip.innerHTML = `
          <div class="tooltip-platform" style="color: ${hoveredSegment.color};">
            <div class="tooltip-circle" style="background-color: ${hoveredSegment.color};"></div>
            ${hoveredSegment.label}
          </div>
          <div class="tooltip-value">${hoveredSegment.value}%</div>
          <div class="tooltip-growth">Traffic Source</div>
        `;
        
        if (window.pieTooltipTimeout) {
          clearTimeout(window.pieTooltipTimeout);
        }
      } else {
        if (window.pieTooltipTimeout) {
          clearTimeout(window.pieTooltipTimeout);
        }
        window.pieTooltipTimeout = setTimeout(() => {
          tooltip.style.display = 'none';
        }, 300);
      }
    } else {
      if (window.pieTooltipTimeout) {
        clearTimeout(window.pieTooltipTimeout);
      }
      window.pieTooltipTimeout = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    if (window.pieTooltipTimeout) {
      clearTimeout(window.pieTooltipTimeout);
    }
    window.pieTooltipTimeout = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

// Chart drawing function
function drawChart() {
  const canvas = document.getElementById('growthChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('chartTooltip');
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Chart margins - increase top margin for legend space
  const margin = { top: 80, right: 5, bottom: 60, left: 80 };  
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  
  // Adjust margins for smaller screens
  if (width < 768) {
    margin.top = 70;  // More top space for legend on mobile
    margin.right = 2;   // Very minimal right margin
    margin.bottom = 40;  
    margin.left = 50;   
  }
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Find max value for scaling
  const maxValue = Math.max(...chartData.datasets.flatMap(d => d.data));
  const scale = chartHeight / maxValue;
  
  // Draw axes only (no grid)
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  // Y-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  
  // X-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Y-axis labels
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (chartHeight * i / 5);
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'right';
    const value = Math.round(maxValue * (5 - i) / 5);
    // Format numbers as k for thousands
    const formattedValue = value >= 1000 ? Math.round(value/1000) + 'k' : value.toString();
    ctx.fillText(formattedValue, margin.left - 10, y + 4);
  }
  
  // X-axis labels
  for (let i = 0; i < chartData.labels.length; i++) {
    const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(chartData.labels[i], x, height - margin.bottom + 20);
  }
  
  // Draw data lines
  chartData.datasets.forEach((dataset, datasetIndex) => {
    ctx.strokeStyle = dataset.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    dataset.data.forEach((value, i) => {
      const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
      const y = margin.top + chartHeight - (value * scale);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    ctx.stroke();
    
    // Draw points
    ctx.fillStyle = dataset.color;
    dataset.data.forEach((value, i) => {
      const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
      const y = margin.top + chartHeight - (value * scale);
      
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();
    });
  });
  
  // Draw legend with better mobile positioning and multi-line support
  const legendStartY = margin.top - 50;  // Move legend further above chart
  let legendX = margin.left;
  let legendY = legendStartY;
  const isMobile = width < 768;
  const maxLegendWidth = chartWidth - 20; // Leave some margin
  
  chartData.datasets.forEach((dataset, i) => {
    const textWidth = ctx.measureText(dataset.label).width;
    const itemWidth = textWidth + 40; // Text width + spacing
    
    // Check if current item would overflow, if so move to next line
    if (legendX + itemWidth > margin.left + maxLegendWidth && i > 0) {
      legendX = margin.left;
      legendY += 25; // Move to next line
    }
    
    // Legend color box
    ctx.fillStyle = dataset.color;
    ctx.fillRect(legendX, legendY, 12, 12);
    
    // Legend text
    ctx.fillStyle = '#fff';
    ctx.font = isMobile ? '10px Manrope, sans-serif' : '12px Manrope, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(dataset.label, legendX + 18, legendY + 9);
    
    legendX += itemWidth;
  });
  
  // Mouse hover functionality
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Find closest data point with even larger detection area
    let closestDistance = Infinity;
    let closestPoint = null;
    
    chartData.datasets.forEach((dataset, datasetIndex) => {
      dataset.data.forEach((value, i) => {
        const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
        const y = margin.top + chartHeight - (value * scale);
        const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        // Much larger detection radius - 60 pixels
        if (distance < 60 && distance < closestDistance) {
          closestDistance = distance;
          const prevValue = i > 0 ? dataset.data[i-1] : dataset.data[i];
          const growthPercent = i > 0 ? (((value - prevValue) / prevValue) * 100).toFixed(1) : 0;
          
          closestPoint = {
            dataset: dataset.label,
            year: chartData.labels[i],
            value: value,
            formattedValue: value >= 1000 ? (value/1000).toFixed(0) + 'k' : value.toLocaleString(),
            growth: growthPercent,
            color: dataset.color,
            // Use actual mouse position for more accurate positioning
            x: e.clientX,
            y: e.clientY
          };
        }
      });
    });
    
    // Show tooltip if we found a point
    if (closestPoint) {
      tooltip.style.display = 'block';
      
      // Position relative to the chart container, not the entire page
      const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
      const relativeX = closestPoint.x - containerRect.left;
      const relativeY = closestPoint.y - containerRect.top;
      
      // Smart positioning within chart boundaries
      const tooltipWidth = 200;
      const tooltipHeight = 120;
      let leftPos = relativeX - 15;
      let topPos = relativeY - 140;
      
      // Keep tooltip within chart container bounds
      if (leftPos + tooltipWidth > containerRect.width) {
        leftPos = containerRect.width - tooltipWidth - 10;
      }
      if (leftPos < 10) {
        leftPos = 10;
      }
      
      if (topPos < 10) {
        topPos = relativeY + 20; // Below cursor if needed
      }
      if (topPos + tooltipHeight > containerRect.height) {
        topPos = containerRect.height - tooltipHeight - 10;
      }
      
      tooltip.style.left = leftPos + 'px';
      tooltip.style.top = topPos + 'px';
      tooltip.innerHTML = `
        <div class="tooltip-platform" style="color: ${closestPoint.color};">
          <div class="tooltip-circle" style="background-color: ${closestPoint.color};"></div>
          ${closestPoint.dataset}
        </div>
        <div class="tooltip-value">${closestPoint.formattedValue}</div>
        <div class="tooltip-growth">+${closestPoint.growth}% vs previous year</div>
        <div class="tooltip-year">${closestPoint.year}</div>
      `;
      
      // Clear any existing timeout
      if (window.tooltipTimeout) {
        clearTimeout(window.tooltipTimeout);
      }
    } else {
      // Longer delay before hiding to prevent flickering
      if (window.tooltipTimeout) {
        clearTimeout(window.tooltipTimeout);
      }
      window.tooltipTimeout = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  // Only hide immediately when mouse leaves canvas completely
  canvas.addEventListener('mouseleave', () => {
    if (window.tooltipTimeout) {
      clearTimeout(window.tooltipTimeout);
    }
    // Longer delay even on mouse leave
    window.tooltipTimeout = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const animatedElements = document.querySelectorAll('.fade-in, .slide-in-left, .slide-in-right, .scale-in');
  animatedElements.forEach(el => observer.observe(el));
  
  // Draw charts after a short delay to ensure canvas is ready
  setTimeout(() => {
    drawChart();
    drawRevenueChart('revenueChart', 'revenueTooltip');
    drawPieChart();
  }, 100);
  
  // Redraw charts on window resize
  window.addEventListener('resize', () => {
    setTimeout(() => {
      drawChart();
      drawRevenueChart('revenueChart', 'revenueTooltip');
      drawPieChart();
    }, 100);
  });
});
</script>
  
</body>
</html>
