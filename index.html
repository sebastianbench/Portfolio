<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sebastian Echavarria</title>

  <style>

    /* 1) Make every element use border-box so borders don't add to width */
*, *::before, *::after {
  box-sizing: border-box;
}

/* 2) (Re-)define your container with a border */
.container {
  /* no more white outline */
  border: none;

  /* shrink to 800px so there's less dead space */
  max-width: 800px;
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
}

    
    /* Typography Hierarchy */
.bold {
  font-family: 'Manrope', sans-serif;
  font-weight: 700;
}

/* H1 - Hero title (keep current size) */
.hero p {
  font-size: 35px; /* Keep as is */
  margin: 0.2rem 0;
}

/* HERO TEXT REVEAL ANIMATION */
.hero p {
  opacity: 0;
  filter: blur(10px);
  transform: translateY(20px);
  animation-fill-mode: forwards;
}

.hero p:nth-child(1) {
  animation: textReveal 1s ease-out 0.5s forwards;
}

.hero p:nth-child(2) {
  animation: textReveal 1s ease-out 1.5s forwards;
}

.hero p:nth-child(3) {
  animation: textReveal 1s ease-out 2.5s forwards;
}

@keyframes textReveal {
  0% {
    opacity: 0;
    filter: blur(10px);
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    filter: blur(0);
    transform: translateY(0);
  }
}

/* H2 - Marketing Manager in main content */
.left-column p .bold {
  font-size: 28px; /* ~80% of H1 */
}

/* H3 - Company name and location in main content */
.left-column p .extralight {
  font-size: 21px; /* ~60% of H1 */
  display: block;
}

/* Paragraph - List items in main content */
.left-column ul li {
  font-size: 16px; /* ~45% of H1 */
}
    
/* — Web-fonts — */
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-ExtraLight.woff') format('woff'),
       url('../fonts/Manrope-ExtraLight.ttf')  format('truetype');
  font-weight: 200;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-Regular.woff') format('woff'),
       url('../fonts/Manrope-Regular.ttf')  format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
@font-face {
  font-family: 'Manrope';
  src: url('../fonts/Manrope-Bold.woff') format('woff'),
       url('../fonts/Manrope-Bold.ttf')  format('truetype');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

.extralight {
  font-family: 'Manrope', sans-serif;
  font-weight: 200;
}

    
    body {
      margin: 0;
      font-family: 'Manrope', sans-serif;
      background-color: #111;
      color: #fff;
      overflow-x: hidden; /* Prevent horizontal scroll during animations */
    }

    /* SCROLL ANIMATIONS */
    .fade-in {
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .slide-in-left {
      opacity: 0;
      transform: translateX(-50px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .slide-in-left.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .slide-in-right {
      opacity: 0;
      transform: translateX(50px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .slide-in-right.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .scale-in {
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .scale-in.visible {
      opacity: 1;
      transform: scale(1);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      margin: 0 auto;
    }

    .avatar {
      border-radius: 50%;
      width: 40px;
      height: 40px;
    }

    .nav-links {
      list-style: none;
      display: flex;
      gap: 1rem;
    }

    .nav-links li a {
      text-decoration: none;
      padding: 0.5rem 1rem;
      background: #222;
      color: #fff;
      border-radius: 8px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .nav-links li a.cta {
      background: #fff;
      color: #111;
      font-weight: 600;
    }

    .nav-links li a:hover {
      background: #333;
    }

    .hero {
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 2rem 1.5rem;  /* More generous padding */
      text-align: left;
      margin: 2rem auto 1rem;  /* Better spacing around hero */
    }

    .hero p {
      font-size: 35px;
      margin: 0.2rem 0;
    }

    .hero p span.bold {
      font-weight: 700;
    }

    .hero p span.light {
      font-weight: 100;
    }

    .content-section {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: space-between;
      padding: 3rem 1.5rem;  /* More generous padding */
      gap: 3rem;  /* More space between columns */
      margin: 0 auto;
    }

    .left-column, .right-column {
      flex: 1 1 45%;
    }

    .left-column img {
      width: 60px;
      margin-bottom: 1.5rem;  /* More space after logo */
    }

    .left-column p {
      font-size: 20px;
      line-height: 1.6;
      margin: 0 0 1.5rem;  /* More space after title block */
    }

    .left-column ul {
      margin-top: 0;
      padding-left: 1.5rem;
      margin-bottom: 4rem;  /* Keep existing bottom spacing */
    }

    .left-column ul li {
      font-size: 16px;
      line-height: 1.7;  /* Better line spacing */
      margin-bottom: 8px;  /* Space between list items */
    }

    .right-column img {
      width: 100%;
      max-width: 800px;  /* Much bigger max width */
      border-radius: 20px;
    }

/* Remove the extra top-margin on the list */
.left-column ul {
  margin-top: 0;
}

    .left-column p {
  margin: 0 0 1rem;
}

   

/* Make the container fluid up to 1200px */
.container {
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
  padding: 0 1rem;
}

/* Responsive two-column content */
.content-section {
  display: flex;
  flex-wrap: wrap;
  gap: 2rem;
}

.content-section > div {
  /* Two columns side by side on desktop */
  flex: 1 1 calc(50% - 2rem);
}



/* Fluid right-column image, no overflow */
.right-column img {
  width: 100%;
  max-width: 800px;  /* Much bigger and responsive */
  border-radius: 20px;
}
  

/* FIXED GALLERY SECTION */
.gallery {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 40px;  /* More breathing room */
  width: 100%;
  max-width: 1800px;
  margin: 80px auto 100px;  /* More space above and below */
  padding: 0 3rem;
  box-sizing: border-box;
}

.gallery-item {
  display: flex;
  flex-direction: column;
  gap: 25px;  /* More space between image and text */
  position: relative;
  z-index: 1;  /* Lower z-index for gallery items */
}

/* Chart container styling */
.chart-container {
  width: 100%;
  height: 400px;
  background-color: #0a0a0a;
  border-radius: 15px;
  padding: 15px;  /* Restore some padding for proper spacing */
  box-sizing: border-box;
  position: relative;
  transition: transform 0.3s ease;
  overflow: visible;  /* Allow tooltip to show outside if needed */
}

/* Text metrics container - similar styling to chart container */
.metrics-container {
  width: 100%;
  height: 400px;
  background-color: #0a0a0a;
  border-radius: 15px;
  padding: 40px 20px;
  box-sizing: border-box;
  position: relative;
  transition: transform 0.3s ease;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

.metrics-container:hover {
  transform: scale(1.02);
}

.metrics-item {
  margin: 20px 0;
  font-family: 'Manrope', sans-serif;
}

.metrics-number {
  font-size: 36px;
  font-weight: 700;
  color: #fff;
  margin-bottom: 8px;
  display: block;
}

.metrics-label {
  font-size: 18px;
  font-weight: 400;
  color: #888;
  display: block;
}

.metrics-number.b2c {
  color: #0064d3;
}

.metrics-number.b2b {
  color: #328bef;
}

    .metrics-number.evergreen {
  color: #dff236; /* Yellow-green */
}

.metrics-number.connected {
  color: #9ba920; /* Orange */
}

/* Mobile adjustments for chart */
@media (max-width: 768px) {
  .chart-container {
    padding: 10px;  /* Minimal but some padding for mobile */
    margin: 0;      /* Remove any extra margins */
  }
  
  .metrics-container {
    padding: 30px 15px;
  }
  
  .metrics-number {
    font-size: 28px;
  }
  
  .metrics-label {
    font-size: 16px;
  }
}

.chart-container:hover {
  transform: scale(1.02);
}

.chart-title {
  font-family: 'Manrope', sans-serif;
  font-weight: 700;
  font-size: 18px;
  color: #fff;
  text-align: center;
  margin-bottom: 20px;
}

.chart-canvas {
  width: 100%;
  height: 100%;  /* Use full container height now */
}

/* Tooltip styling */
.chart-tooltip {
  position: absolute !important;  /* Absolute positioning relative to chart container */
  background-color: rgba(0, 0, 0, 0.95);
  border: 1px solid #444;
  border-radius: 12px;
  padding: 16px;
  font-family: 'Manrope', sans-serif;
  color: #fff;
  pointer-events: none;
  z-index: 100;  /* High within the chart container */
  display: none;
  min-width: 200px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.tooltip-platform {
  font-size: 14px;
  font-weight: 700;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
}

.tooltip-circle {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.tooltip-value {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 4px;
}

.tooltip-growth {
  font-size: 12px;
  font-weight: 600;
  color: #4ade80;
}

.tooltip-year {
  font-size: 12px;
  color: #888;
  margin-top: 8px;
}

.gallery-item img {
  width: 100%;
  height: 400px;
  object-fit: contain;  /* Show full image, no cropping */
  object-position: center;
  border-radius: 15px;
  transition: transform 0.3s ease;
  background-color: #1a1a1a;  /* Dark background for letterboxing if needed */
  position: relative;
  z-index: 1;  /* Lower z-index for images */
}

.gallery-item img:hover {
  transform: scale(1.02);
}

.gallery-caption p {
  font-size: 16px;
  line-height: 1.6;  /* Better line spacing */
  margin: 0 0 20px 0;  /* Space below title */
}

/* H3 - Gallery titles */
.gallery-caption .bold {
  font-size: 21px;
}

.gallery-caption .extralight {
  font-size: 21px;
  display: block;
  margin-bottom: 10px;
}

.gallery-caption ul {
  margin: 0;
  padding-left: 1.5rem;
}

/* Paragraph - Gallery list items */
.gallery-caption ul li {
  font-size: 16px;
  line-height: 1.6;  /* Better line spacing */
  margin-bottom: 10px;  /* More space between list items */
}

/* Tablet view - Better responsive handling */
@media (max-width: 1200px) and (min-width: 769px) {
  .gallery {
    grid-template-columns: 1fr 1fr;
    max-width: 95%;
    gap: 25px;
    margin: 60px auto 80px;
    padding: 0 2rem;
  }
  
  .gallery-item {
    gap: 20px;
  }
  
  .gallery-item img {
    height: 320px;
    object-fit: contain;
  }
  
  .gallery-caption p {
    margin-bottom: 15px;
  }
}

/* Large tablet view */
@media (max-width: 1024px) and (min-width: 901px) {
  .gallery {
    grid-template-columns: repeat(3, 1fr);
    max-width: 98%;
    gap: 20px;
  }
  
  .gallery-item img {
    height: 280px;
    object-fit: contain;
  }
}

/* Medium tablet */
@media (max-width: 900px) and (min-width: 769px) {
  .gallery {
    grid-template-columns: 1fr 1fr;
    max-width: 90%;
    gap: 30px;
  }
  
  .gallery-item img {
    height: 300px;
    object-fit: contain;
  }
}

/* Mobile view - Much more generous spacing */
@media (max-width: 768px) {
  .gallery {
    grid-template-columns: 1fr;
    max-width: 100%;
    padding: 0 1rem;  /* Add padding back on mobile for text breathing room */
    margin: 50px auto 60px;  /* Generous vertical margins */
    gap: 50px;  /* Much more space between items */
  }
  
  .gallery-item {
    gap: 30px;  /* More space between image and text */
  }
  
  .gallery-item img {
    height: 250px;  /* Good size for mobile */
    object-fit: contain;  /* Show full image on mobile too */
  }
  
  .gallery-caption p {
    margin-bottom: 20px;  /* More space below title */
  }
  
  .gallery-caption ul li {
    margin-bottom: 12px;  /* More space between bullet points */
    line-height: 1.7;  /* Even better line spacing on mobile */
  }
}

/* Force all text to white */
body {
  color: #fff !important;
}

  @media (max-width: 768px) {
  /* Hero section - more breathing room */
  .hero {
    padding: 2.5rem 1rem;
    margin: 1.5rem auto 2rem;
  }

  /* Content section - better mobile spacing */
  .content-section {
    display: flex;
    flex-direction: column;
    gap: 0;
    padding: 2rem 1rem;  /* More generous mobile padding */
  }

  .content-section .right-column {
    order: -1;
    margin: 0 0 2rem;  /* Clean spacing below image */
  }

  .content-section .left-column {
    margin: 0;
  }

  .content-section .left-column img {
    margin-bottom: 2rem;  /* More space after logo */
  }

  .content-section .left-column p {
    margin-bottom: 2rem;  /* More space after title block */
  }

  .content-section .left-column ul {
    margin-bottom: 3rem;  /* Space before gallery */
  }

  .content-section .left-column ul li {
    margin-bottom: 10px;  /* More space between mobile list items */
    line-height: 1.8;  /* Better line spacing on mobile */
  }

  .content-section .right-column img {
    margin: 0;
  }

  /* Container adjustments */
  .container {
    max-width: none;
    width: 100%;
    padding: 0;
    margin: 0;
  }

  /* Navigation and sections */
  .nav,
  .hero,
  .content-section {
    width: 100%;
    margin: 0 auto;
  }

  /* Navigation spacing */
  .nav {
    margin: 2rem 0 !important;
    padding: 0 1rem;
  }
}

    /* 5) Add vertical breathing room around the nav */
.nav {
    margin: 1.5rem 0 !important;
  }

/* 6) Push the hero text down from the top */
.hero {
  margin-top: 2rem;  /* 3rem above "Sebastian …" */
}


/* 3rem space after the left-column text block */
.left-column ul {
  margin-bottom: 3rem;
}

    .custom-button {
  display: inline-block;
  padding: 10px 20px;
  margin-top: 1.5rem;
  border-radius: 999px; /* pill shape */
  font-family: 'Manrope', sans-serif;
  font-weight: 600;
  font-size: 14px;
  text-align: center;
  text-decoration: none;
  transition: background-color 0.2s ease;
}

.custom-button.grey {
  background-color: #444;
  color: #fff;
}

.custom-button.grey:hover {
  background-color: #666;
}

.custom-button.white {
  background-color: #fff;
  color: #111;
}

.custom-button.white:hover {
  background-color: #eee;
}


    
  </style>
</head>
<body>

  
  <div class="container">

  
  <header>
    <nav class="nav fade-in">
      <div class="logo">
        <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Cover%20image%20CV4.png?raw=true" alt="Profile" class="avatar" />
      </div>
      <ul class="nav-links">
  <li><a href="#" class="cta">Contact</a></li>
</ul>

    </nav>
    <div class="hero">
      <p><span class="bold">Sebastian Echavarria.</span></p>
<p><span class="bold">Marketing</span> <span class="extralight">Manager.</span></p>
<p><span class="bold">Creative</span> <span class="extralight">Director.</span></p>
    </div>
  </header>
  
  <!-- FIRST SECTION -->
  <section class="content-section">
    <div class="left-column slide-in-left">
      <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/rbm_logov2.png?raw=true" alt="RBM Logo">
       <p>
      <span class="bold">Marketing Manager.</span><br>
      <span class="extralight">
        Red Bow Music.<br>
        Bremen, Germany.
      </span>
    </p>
    <ul>
      <li>Founder of a company.</li>
      <li>1000 orders in the first year.</li>
      <li>9000+ orders since.</li>
    </ul>
<div style="margin-top: 1rem; padding-left: 0;">
  <a href="https://your-redbow-website.com" class="cta" style="display: inline-block; margin-top: 1rem;">See website</a>
</div>


  </div>
  <div class="right-column slide-in-right">
    <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Iphone%20RBM%2004.jpg?raw=true"
         alt="Phone Preview">
  </div>
</section>
    </div>

<!-- FIRST GALLERY -->
<section class="gallery">
  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="growthChart"></canvas>
      <div class="chart-tooltip" id="chartTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Fast Growth.</span><br />
      </p>
      <ul>
        <li>Grew by 100% in the 2nd year</li>
        <li>Over 2 Mio. likes in the 5th year</li>
        <li>Completely organic, no ads</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="revenueChart"></canvas>
      <div class="chart-tooltip" id="revenueTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Email Performance.</span><br />
      </p>
      <ul>
        <li>35% open rate in 2025</li>
        <li>Consistent year-over-year growth</li>
        <li>Strong B2B engagement metrics</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="pieChart"></canvas>
      <div class="chart-tooltip" id="pieTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Organic Growth.</span><br />
      </p>
      <ul>
        <li>99% organic traffic</li>
        <li>Zero paid advertising</li>
        <li>Pure content-driven results</li>
      </ul>
    </div>
  </div>
</section>

<!-- SECOND SECTION (DUPLICATED) -->
<div class="container">
  <section class="content-section">
    <div class="left-column slide-in-left">
      <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/repareo_logo.png?raw=true" alt="Repareo Logo">
       <p>
      <span class="bold">CRM Werkstudent.</span><br>
      <span class="extralight">
        repareo GmbH.<br>
        Munich, Germany.
      </span>
    </p>
    <ul>
      <li>Founder of a company.</li>
      <li>1000 orders in the first year.</li>
      <li>9000+ orders since.</li>
    </ul>
<div style="margin-top: 1rem; padding-left: 0;">
  <a href="https://your-repareo-reference.com" class="cta">See reference</a>
</div>

  </div>
  <div class="right-column slide-in-right">
    <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Images 06.jpg?raw=true"
         alt="Second Project Preview">
  </div>
</section>
</div>

<!-- SECOND GALLERY (DUPLICATED) -->
<section class="gallery">
  <div class="gallery-item scale-in">
    <div class="metrics-container">
      <div class="metrics-item">
        <span class="metrics-number b2c">+4,800</span>
        <span class="metrics-label">B2C conversions</span>
      </div>
      <div class="metrics-item">
        <span class="metrics-number b2b">+120</span>
        <span class="metrics-label">new B2B partners</span>
      </div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Key Results.</span><br />
      </p>
      <ul>
        <li>4,800 direct customer conversions</li>
        <li>120 new business partnerships</li>
        <li>Consistent growth quarter over quarter</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="revenueChart2"></canvas>
      <div class="chart-tooltip" id="revenueTooltip2"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Reliable Results.</span><br />
      </p>
      <ul>
        <li>Consistent positive results</li>
        <li>1000+ orders per year</li>
        <li>Slowly increasing income</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
      <canvas class="chart-canvas" id="efficiencyChart"></canvas>
      <div class="chart-tooltip" id="efficiencyTooltip"></div>
    </div>
    <div class="gallery-caption">
      <p>
        <span class="bold">Process Efficiency.</span><br />
      </p>
      <ul>
        <li>Reduced workload from 17h to 4h per week</li>
        <li>76% efficiency improvement over 2 years</li>
        <li>Streamlined B2B operations</li>
      </ul>
    </div>
  </div>
</section>

<!-- THIRD SECTION (EVERJUMP) -->
<div class="container">
  <section class="content-section">
    <div class="left-column slide-in-left">
      <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/everjump_logo.png?raw=true" alt="Everjump Logo">
       <p>
      <span class="bold">Marketing Manager.</span><br>
      <span class="extralight">
        Everjump GmbH.<br>
        Berlin, Germany.
      </span>
    </p>
    <ul>
      <li>Founder of a company.</li>
      <li>1000 orders in the first year.</li>
      <li>9000+ orders since.</li>
    </ul>
<div style="margin-top: 1rem; padding-left: 0;">
  <a href="https://your-everjump-reference.com" class="cta">See reference</a>
</div>



  </div>
  <div class="right-column slide-in-right">
    <img src="https://github.com/sebastianbench/Portfolio/blob/main/images/Ejerjump%20new%20capture%200911.jpg?raw=true"
         alt="Everjump Project Preview">
  </div>
</section>
</div>

  
<!-- THIRD GALLERY (EVERJUMP) -->
<section class="gallery">
  <div class="gallery-item scale-in">
    <div class="chart-container">
  <canvas class="chart-canvas" id="efficiencyChart3"></canvas>
  <div class="chart-tooltip" id="efficiencyTooltip3"></div>
</div>


    <div class="gallery-caption">
      <p>
        <span class="bold">Gallery Item 1.</span><br />
      </p>
      <ul>
        <li>Item detail 1</li>
        <li>Item detail 2</li>
        <li>Item detail 3</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
    <div class="chart-container">
  <canvas class="chart-canvas" id="revenueChart3"></canvas>
  <div class="chart-tooltip" id="revenueTooltip3"></div>
</div>

    <div class="gallery-caption">
      <p>
        <span class="bold">Gallery Item 2.</span><br />
      </p>
      <ul>
        <li>Item detail 1</li>
        <li>Item detail 2</li>
        <li>Item detail 3</li>
      </ul>
    </div>
  </div>

  <div class="gallery-item scale-in">
  <div class="metrics-container">
    <div class="metrics-item">
      <span class="metrics-number evergreen">+12</span>
<span class="metrics-label">evergreen campaigns</span>
    </div>
    <div class="metrics-item">
      <span class="metrics-number connected">+10,000</span>
<span class="metrics-label">customers connected</span>
    </div>
  </div>
  <div class="gallery-caption">
    <p>
      <span class="bold">Engagement Results.</span><br />
    </p>
    <ul>
      <li>4,800 new user conversions</li>
      <li>120 B2B onboarding successes</li>
      <li>Audience growth year over year</li>
    </ul>
  </div>
</div>

</section>

<script>
// Scroll animation observer
const observerOptions = {
  threshold: 0.1,
  rootMargin: '0px 0px -50px 0px'
};

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    }
  });
}, observerOptions);

// Pie Chart Data
const pieData = {
  labels: ['Organic', 'Paid'],
  data: [99, 1],
  colors: ['#323131', '#880423']
};

// Revenue Chart Data
const revenueData = {
  labels: ["'20", "'21", "'22", "'23", "'24", "'25"],
  data: [0.05, 0.1, 2, 10, 22, 30],
  colors: ['#323131', '#323131', '#323131', '#323131', '#323131', '#880423']  // Updated grey color
};

// Growth Chart Data
const chartData = {
  labels: ["'20", "'21", "'22", "'23", "'24", "'25"],
  datasets: [
    {
      label: 'YouTube',
      data: [1000, 3000, 6000, 25000, 55000, 130000],
      color: '#8a0324'
    },
    {
      label: 'TikTok', 
      data: [3000, 7000, 10000, 30000, 65000, 95000],
      color: '#c1123d'
    },
    {
      label: 'Instagram',
      data: [500, 600, 1500, 15000, 55000, 85000],
      color: '#ff406f'
    }
  ]
};

  // NEW: 2nd set of colors for the duplicated charts
const chartData2 = {
  labels: ["'20", "'21", "'22", "'23", "'24", "'25"],
  datasets: [
    {
      label: 'YouTube',
      data: [800, 1500, 3000, 8000, 20000, 50000],
      color: '#1c3a5b' // dark blue
    },
    {
      label: 'TikTok',
      data: [1000, 2000, 4000, 15000, 30000, 45000],
      color: '#0064d3' // blue
    },
    {
      label: 'Instagram',
      data: [400, 500, 1200, 7000, 18000, 30000],
      color: '#3b98ff' // light blue
    }
  ]
};

const revenueData2 = {
  labels: ["'23", "'24", "'25"],
  data: [26, 32, 35],
  colors: ['#323131', '#323131', '#328bef']
};

  const revenueData3 = {
  labels: ["'22", "'23"],
  data: [12, 18], // Represented in thousands (€10k, €20k)
  colors: ['#323131', '#ddf136']  // Pick two colors or reuse these
};
  
const efficiencyData = {
  labels: ["'23", "'24", "'25"],
  data: [17, 10, 4],
  color: '#0064d3',
  fillColor: 'rgba(50, 139, 239, 0.3)' // Light blue with transparency
};

  const efficiencyData3 = {
  labels: ["'21", "'22", "'23"],
  data: [10000, 600000, 900000],
  color: '#dff236',
  fillColor: 'rgba(223, 242, 54, 0.2)' // lighter yellow-green
};

// Revenue Bar Chart drawing function
function drawRevenueChart(canvasId = 'revenueChart', tooltipId = 'revenueTooltip', revenueDataInput = revenueData) {
  const revenueData = revenueDataInput;
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Chart margins
  const margin = { top: 40, right: 5, bottom: 60, left: 60 };  
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  
  // Adjust margins for smaller screens
  if (width < 768) {
    margin.top = 30;  
    margin.right = 2;   
    margin.bottom = 40;  
    margin.left = 45;   
  }
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Find max value for scaling
  const maxValue = Math.max(...revenueData.data);
  const scale = chartHeight / maxValue;
  
  // Draw axes
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  // Y-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  
  // X-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Y-axis labels
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (chartHeight * i / 5);
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'right';
    const value = Math.round(maxValue * (5 - i) / 5);
    // Format as percentage for email open rates, or currency for revenue
    const formattedValue = canvasId === 'revenueChart2' ? value + '%' : 
                          (value >= 1 ? value + 'k €' : (value * 1000) + ' €');
    ctx.fillText(formattedValue, margin.left - 10, y + 4);
  }
  
  // Draw bars with rounded tops
  const barWidth = chartWidth / revenueData.data.length * 0.6; // 60% width with spacing
  const barSpacing = chartWidth / revenueData.data.length;
  const borderRadius = 8; // Radius for rounded tops
  
  revenueData.data.forEach((value, i) => {
    const barHeight = value * scale;
    const x = margin.left + (barSpacing * i) + (barSpacing - barWidth) / 2;
    const y = margin.top + chartHeight - barHeight;
    
    // Draw bar with rounded top
    ctx.fillStyle = revenueData.colors[i];
    ctx.beginPath();
    
    if (barHeight > borderRadius) {
      // Rectangle body
      ctx.rect(x, y + borderRadius, barWidth, barHeight - borderRadius);
      // Rounded top
      ctx.moveTo(x, y + borderRadius);
      ctx.arcTo(x, y, x + borderRadius, y, borderRadius);
      ctx.lineTo(x + barWidth - borderRadius, y);
      ctx.arcTo(x + barWidth, y, x + barWidth, y + borderRadius, borderRadius);
      ctx.lineTo(x + barWidth, y + barHeight);
      ctx.lineTo(x, y + barHeight);
      ctx.closePath();
    } else {
      // For very small bars, just draw a rounded rectangle
      ctx.roundRect(x, y, barWidth, barHeight, [borderRadius, borderRadius, 0, 0]);
    }
    
    ctx.fill();
    
    // X-axis labels
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(revenueData.labels[i], x + barWidth/2, height - margin.bottom + 20);
  });
  
  // Mouse hover functionality for bars
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    let hoveredBar = null;
    
    revenueData.data.forEach((value, i) => {
      const barHeight = value * scale;
      const x = margin.left + (barSpacing * i) + (barSpacing - barWidth) / 2;
      const y = margin.top + chartHeight - barHeight;
      
      // Check if mouse is over this bar
      if (mouseX >= x && mouseX <= x + barWidth && mouseY >= y && mouseY <= y + barHeight) {
        const prevValue = i > 0 ? revenueData.data[i-1] : revenueData.data[i];
        const growthPercent = i > 0 ? (((value - prevValue) / prevValue) * 100).toFixed(1) : 0;
        
        hoveredBar = {
          year: revenueData.labels[i],
          value: value,
          formattedValue: canvasId === 'revenueChart2' ? value + '%' : 
                         (value >= 1 ? value + 'k €' : (value * 1000) + ' €'),
          growth: growthPercent,
          color: revenueData.colors[i],
          x: e.clientX,
          y: e.clientY
        };
      }
    });
    
    if (hoveredBar) {
      const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
      const relativeX = hoveredBar.x - containerRect.left;
      const relativeY = hoveredBar.y - containerRect.top;
      
      const tooltipWidth = 200;
      const tooltipHeight = 120;
      let leftPos = relativeX - 15;
      let topPos = relativeY - 140;
      
      // Keep tooltip within chart container bounds
      if (leftPos + tooltipWidth > containerRect.width) {
        leftPos = containerRect.width - tooltipWidth - 10;
      }
      if (leftPos < 10) {
        leftPos = 10;
      }
      
      if (topPos < 10) {
        topPos = relativeY + 20;
      }
      if (topPos + tooltipHeight > containerRect.height) {
        topPos = containerRect.height - tooltipHeight - 10;
      }
      
      tooltip.style.display = 'block';
      tooltip.style.left = leftPos + 'px';
      tooltip.style.top = topPos + 'px';
      tooltip.innerHTML = `
        <div class="tooltip-platform" style="color: ${hoveredBar.color};">
          <div class="tooltip-circle" style="background-color: ${hoveredBar.color};"></div>
          Revenue
        </div>
        <div class="tooltip-value">${hoveredBar.formattedValue}</div>
        <div class="tooltip-growth">+${hoveredBar.growth}% vs previous year</div>
        <div class="tooltip-year">${hoveredBar.year}</div>
      `;
      
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
    } else {
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
      window[timeoutKey] = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    const timeoutKey = `${canvasId}TooltipTimeout`;
    if (window[timeoutKey]) {
      clearTimeout(window[timeoutKey]);
    }
    window[timeoutKey] = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

  function drawRevenueChart3() {
  drawRevenueChart('revenueChart3', 'revenueTooltip3', revenueData3);
}


// Pie Chart drawing function
function drawPieChart(canvasId = 'pieChart', tooltipId = 'pieTooltip', pieDataInput = pieData) {
  const pieData = pieDataInput;
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Calculate center and radius
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) * 0.35; // Outer radius
  const innerRadius = radius * 0.5; // Inner radius for donut effect
  
  // Calculate angles
  let currentAngle = -Math.PI / 2; // Start at top
  const segments = [];
  
  pieData.data.forEach((value, i) => {
    const sliceAngle = (value / 100) * 2 * Math.PI;
    
    segments.push({
      startAngle: currentAngle,
      endAngle: currentAngle + sliceAngle,
      value: value,
      label: pieData.labels[i],
      color: pieData.colors[i]
    });
    
    currentAngle += sliceAngle;
  });
  
  // Draw segments
  segments.forEach(segment => {
    // Draw outer arc
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, segment.startAngle, segment.endAngle);
    ctx.arc(centerX, centerY, innerRadius, segment.endAngle, segment.startAngle, true);
    ctx.closePath();
    ctx.fillStyle = segment.color;
    ctx.fill();
  });
  
// ⬇️ ADD LEGEND HERE (top)
// Responsive top legend
let legendX = 20;
let legendY = 20;
const maxLegendWidth = width - 40; // 20px padding on both sides

segments.forEach((segment, i) => {
  const labelText = segment.label;
  const textWidth = ctx.measureText(labelText).width;
  const itemWidth = textWidth + 32; // box + spacing

  // Wrap to next line if too wide
  if (legendX + itemWidth > maxLegendWidth) {
    legendX = 20;
    legendY += 24;
  }

  // Draw color box
  ctx.fillStyle = segment.color;
  ctx.fillRect(legendX, legendY, 12, 12);

  // Draw label text
  ctx.fillStyle = '#fff';
  ctx.font = '12px Manrope, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(labelText, legendX + 18, legendY + 10);

  // Move to next item position
  legendX += itemWidth;
});

  
  // Mouse hover functionality
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Check if mouse is over any segment
    const distanceFromCenter = Math.sqrt((mouseX - centerX) ** 2 + (mouseY - centerY) ** 2);
    
    if (distanceFromCenter >= innerRadius && distanceFromCenter <= radius) {
      // Calculate angle from center to mouse
      const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
      const normalizedAngle = angle < -Math.PI / 2 ? angle + 2 * Math.PI : angle;
      
      // Find which segment the mouse is over
      const hoveredSegment = segments.find(segment => {
        let startAngle = segment.startAngle;
        let endAngle = segment.endAngle;
        
        // Normalize angles for comparison
        if (startAngle < -Math.PI / 2) startAngle += 2 * Math.PI;
        if (endAngle < -Math.PI / 2) endAngle += 2 * Math.PI;
        
        return normalizedAngle >= startAngle && normalizedAngle <= endAngle;
      });
      
      if (hoveredSegment) {
        const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
        const relativeX = e.clientX - containerRect.left;
        const relativeY = e.clientY - containerRect.top;
        
        const tooltipWidth = 200;
        const tooltipHeight = 100;
        let leftPos = relativeX - 15;
        let topPos = relativeY - 120;
        
        // Keep tooltip within chart container bounds
        if (leftPos + tooltipWidth > containerRect.width) {
          leftPos = containerRect.width - tooltipWidth - 10;
        }
        if (leftPos < 10) {
          leftPos = 10;
        }
        
        if (topPos < 10) {
          topPos = relativeY + 20;
        }
        if (topPos + tooltipHeight > containerRect.height) {
          topPos = containerRect.height - tooltipHeight - 10;
        }
        
        tooltip.style.display = 'block';
        tooltip.style.left = leftPos + 'px';
        tooltip.style.top = topPos + 'px';
        tooltip.innerHTML = `
          <div class="tooltip-platform" style="color: ${hoveredSegment.color};">
            <div class="tooltip-circle" style="background-color: ${hoveredSegment.color};"></div>
            ${hoveredSegment.label}
          </div>
          <div class="tooltip-value">${hoveredSegment.value}%</div>
          <div class="tooltip-growth">Traffic Source</div>
        `;
        
        const timeoutKey = `${canvasId}TooltipTimeout`;
        if (window[timeoutKey]) {
          clearTimeout(window[timeoutKey]);
        }
      } else {
        const timeoutKey = `${canvasId}TooltipTimeout`;
        if (window[timeoutKey]) {
          clearTimeout(window[timeoutKey]);
        }
        window[timeoutKey] = setTimeout(() => {
          tooltip.style.display = 'none';
        }, 300);
      }
    } else {
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
      window[timeoutKey] = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    const timeoutKey = `${canvasId}TooltipTimeout`;
    if (window[timeoutKey]) {
      clearTimeout(window[timeoutKey]);
    }
    window[timeoutKey] = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

// Efficiency Line Chart drawing function
function drawEfficiencyChart(canvasId = 'efficiencyChart', tooltipId = 'efficiencyTooltip') {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Chart margins
  const margin = { top: 40, right: 20, bottom: 60, left: 60 };  
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  
  // Adjust margins for smaller screens
  if (width < 768) {
    margin.top = 30;  
    margin.right = 15;   
    margin.bottom = 40;  
    margin.left = 45;   
  }
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Max value is 20 for hours
  const maxValue = 20;
  const scale = chartHeight / maxValue;
  
  // Draw axes
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  // Y-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  
  // X-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Y-axis labels (0 to 20 hours)
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (chartHeight * i / 5);
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'right';
    const value = Math.round(maxValue * (5 - i) / 5);
    ctx.fillText(value + 'h', margin.left - 10, y + 4);
  }
  
  // X-axis labels
  for (let i = 0; i < efficiencyData.labels.length; i++) {
    const x = margin.left + (chartWidth * i / (efficiencyData.labels.length - 1));
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(efficiencyData.labels[i], x, height - margin.bottom + 20);
  }
  
  // Create path for filled area
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight); // Start at bottom-left
  
  // Draw line points and create fill path
  const points = [];
  efficiencyData.data.forEach((value, i) => {
    const x = margin.left + (chartWidth * i / (efficiencyData.data.length - 1));
    const y = margin.top + chartHeight - (value * scale);
    points.push({x, y, value, label: efficiencyData.labels[i]});
    ctx.lineTo(x, y);
  });
  
  // Complete the fill area by going to bottom-right and closing
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.closePath();
  
  // Fill the area under the line
  ctx.fillStyle = efficiencyData.fillColor;
  ctx.fill();
  
  // Draw the line on top
  ctx.strokeStyle = efficiencyData.color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  
  efficiencyData.data.forEach((value, i) => {
    const x = margin.left + (chartWidth * i / (efficiencyData.data.length - 1));
    const y = margin.top + chartHeight - (value * scale);
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  
  ctx.stroke();
  
  // Draw points
  ctx.fillStyle = efficiencyData.color;
  points.forEach(point => {
    ctx.beginPath();
    ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
    ctx.fill();
  });
  
  // Mouse hover functionality
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Find closest data point
    let closestDistance = Infinity;
    let closestPoint = null;
    
    points.forEach((point, i) => {
      const distance = Math.sqrt((mouseX - point.x) ** 2 + (mouseY - point.y) ** 2);
      
      if (distance < 40 && distance < closestDistance) {
        closestDistance = distance;
        const prevValue = i > 0 ? efficiencyData.data[i-1] : efficiencyData.data[i];
        const changePercent = i > 0 ? (((point.value - prevValue) / prevValue) * 100).toFixed(1) : 0;
        const changeText = changePercent < 0 ? `${changePercent}%` : `+${changePercent}%`;
        
        closestPoint = {
          year: point.label,
          value: point.value,
          change: changeText,
          x: e.clientX,
          y: e.clientY
        };
      }
    });
    
    if (closestPoint) {
      const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
      const relativeX = closestPoint.x - containerRect.left;
      const relativeY = closestPoint.y - containerRect.top;
      
      const tooltipWidth = 200;
      const tooltipHeight = 120;
      let leftPos = relativeX - 15;
      let topPos = relativeY - 140;
      
      // Keep tooltip within chart container bounds
      if (leftPos + tooltipWidth > containerRect.width) {
        leftPos = containerRect.width - tooltipWidth - 10;
      }
      if (leftPos < 10) {
        leftPos = 10;
      }
      
      if (topPos < 10) {
        topPos = relativeY + 20;
      }
      if (topPos + tooltipHeight > containerRect.height) {
        topPos = containerRect.height - tooltipHeight - 10;
      }
      
      tooltip.style.display = 'block';
      tooltip.style.left = leftPos + 'px';
      tooltip.style.top = topPos + 'px';
      tooltip.innerHTML = `
        <div class="tooltip-platform" style="color: ${efficiencyData.color};">
          <div class="tooltip-circle" style="background-color: ${efficiencyData.color};"></div>
          Hours per Week
        </div>
        <div class="tooltip-value">${closestPoint.value}h</div>
        <div class="tooltip-growth">${closestPoint.change} vs previous year</div>
        <div class="tooltip-year">${closestPoint.year}</div>
      `;
      
      if (window.efficiencyTooltipTimeout) {
        clearTimeout(window.efficiencyTooltipTimeout);
      }
    } else {
      if (window.efficiencyTooltipTimeout) {
        clearTimeout(window.efficiencyTooltipTimeout);
      }
      window.efficiencyTooltipTimeout = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    if (window.efficiencyTooltipTimeout) {
      clearTimeout(window.efficiencyTooltipTimeout);
    }
    window.efficiencyTooltipTimeout = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

  function drawEfficiencyChart3(canvasId = 'efficiencyChart3', tooltipId = 'efficiencyTooltip3') {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);

  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  const width = rect.width;
  const height = rect.height;
  const margin = { top: 40, right: 20, bottom: 60, left: 60 };
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;

  const maxValue = 1000000;
const scale = chartHeight / maxValue;


  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);

  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();

  for (let i = 0; i <= 5; i++) {
  const y = margin.top + (chartHeight * i / 5);
  const value = Math.round(1000000 * (5 - i) / 5); // from 1M down to 0
  ctx.fillStyle = '#888';
  ctx.font = '12px Manrope, sans-serif';
  ctx.textAlign = 'right';
  const label = value >= 1000000 ? (value / 1000000) + 'M' : (value / 1000) + 'k';
  ctx.fillText(label, margin.left - 10, y + 4);
}

  for (let i = 0; i < efficiencyData3.labels.length; i++) {
    const x = margin.left + (chartWidth * i / (efficiencyData3.labels.length - 1));
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(efficiencyData3.labels[i], x, height - margin.bottom + 20);
  }

  const points = efficiencyData3.data.map((value, i) => {
    const x = margin.left + (chartWidth * i / (efficiencyData3.data.length - 1));
    const y = margin.top + chartHeight - (value * scale);
    return { x, y, value, label: efficiencyData3.labels[i] };
  });

  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  points.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.closePath();
  ctx.fillStyle = efficiencyData3.fillColor;
  ctx.fill();

  ctx.strokeStyle = efficiencyData3.color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
  ctx.stroke();

  ctx.fillStyle = efficiencyData3.color;
  points.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
    ctx.fill();
  });

    canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  let closestDistance = Infinity;
  let closestPoint = null;

  points.forEach((point, i) => {
    const distance = Math.sqrt((mouseX - point.x) ** 2 + (mouseY - point.y) ** 2);
    if (distance < 40 && distance < closestDistance) {
      closestDistance = distance;
      const prevValue = i > 0 ? efficiencyData3.data[i-1] : efficiencyData3.data[i];
      const changePercent = i > 0 ? (((point.value - prevValue) / prevValue) * 100).toFixed(1) : 0;
      const changeText = changePercent < 0 ? `${changePercent}%` : `+${changePercent}%`;

      closestPoint = {
        year: point.label,
        value: point.value,
        change: changeText,
        x: e.clientX,
        y: e.clientY
      };
    }
  });

  if (closestPoint) {
    const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
    const relativeX = closestPoint.x - containerRect.left;
    const relativeY = closestPoint.y - containerRect.top;

    const tooltip = document.getElementById('efficiencyTooltip3');
    const tooltipWidth = 200;
    const tooltipHeight = 120;
    let leftPos = relativeX - 15;
    let topPos = relativeY - 140;

    if (leftPos + tooltipWidth > containerRect.width) leftPos = containerRect.width - tooltipWidth - 10;
    if (leftPos < 10) leftPos = 10;
    if (topPos < 10) topPos = relativeY + 20;
    if (topPos + tooltipHeight > containerRect.height) topPos = containerRect.height - tooltipHeight - 10;

    tooltip.style.display = 'block';
    tooltip.style.left = leftPos + 'px';
    tooltip.style.top = topPos + 'px';
    tooltip.innerHTML = `
      <div class="tooltip-platform" style="color: ${efficiencyData3.color};">
        <div class="tooltip-circle" style="background-color: ${efficiencyData3.color};"></div>
        Views
      </div>
      <div class="tooltip-value">${closestPoint.value.toLocaleString()} views</div>
      <div class="tooltip-growth">${closestPoint.change} vs previous year</div>
      <div class="tooltip-year">${closestPoint.year}</div>
    `;

    if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
  } else {
    if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
    window.efficiencyTooltip3Timeout = setTimeout(() => {
      document.getElementById('efficiencyTooltip3').style.display = 'none';
    }, 300);
  }
});

canvas.addEventListener('mouseleave', () => {
  if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
  window.efficiencyTooltip3Timeout = setTimeout(() => {
    document.getElementById('efficiencyTooltip3').style.display = 'none';
  }, 200);
});
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  let closestDistance = Infinity;
  let closestPoint = null;

  points.forEach((point, i) => {
    const distance = Math.sqrt((mouseX - point.x) ** 2 + (mouseY - point.y) ** 2);
    if (distance < 40 && distance < closestDistance) {
      closestDistance = distance;
      const prevValue = i > 0 ? efficiencyData3.data[i-1] : efficiencyData3.data[i];
      const changePercent = i > 0 ? (((point.value - prevValue) / prevValue) * 100).toFixed(1) : 0;
      const changeText = changePercent < 0 ? `${changePercent}%` : `+${changePercent}%`;

      closestPoint = {
        year: point.label,
        value: point.value,
        change: changeText,
        x: e.clientX,
        y: e.clientY
      };
    }
  });

  if (closestPoint) {
    const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
    const relativeX = closestPoint.x - containerRect.left;
    const relativeY = closestPoint.y - containerRect.top;

    const tooltip = document.getElementById('efficiencyTooltip3');
    const tooltipWidth = 200;
    const tooltipHeight = 120;
    let leftPos = relativeX - 15;
    let topPos = relativeY - 140;

    if (leftPos + tooltipWidth > containerRect.width) leftPos = containerRect.width - tooltipWidth - 10;
    if (leftPos < 10) leftPos = 10;
    if (topPos < 10) topPos = relativeY + 20;
    if (topPos + tooltipHeight > containerRect.height) topPos = containerRect.height - tooltipHeight - 10;

    tooltip.style.display = 'block';
    tooltip.style.left = leftPos + 'px';
    tooltip.style.top = topPos + 'px';
    tooltip.innerHTML = `
      <div class="tooltip-platform" style="color: ${efficiencyData3.color};">
        <div class="tooltip-circle" style="background-color: ${efficiencyData3.color};"></div>
        Views
      </div>
      <div class="tooltip-value">${closestPoint.value.toLocaleString()} views</div>
      <div class="tooltip-growth">${closestPoint.change} vs previous year</div>
      <div class="tooltip-year">${closestPoint.year}</div>
    `;

    if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
  } else {
    if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
    window.efficiencyTooltip3Timeout = setTimeout(() => {
      document.getElementById('efficiencyTooltip3').style.display = 'none';
    }, 300);
  }
});

canvas.addEventListener('mouseleave', () => {
  if (window.efficiencyTooltip3Timeout) clearTimeout(window.efficiencyTooltip3Timeout);
  window.efficiencyTooltip3Timeout = setTimeout(() => {
    document.getElementById('efficiencyTooltip3').style.display = 'none';
  }, 200);
});

}


// Chart drawing function
function drawChart(canvasId = 'growthChart', tooltipId = 'chartTooltip', chartDataInput = chartData) {
  const chartData = chartDataInput;
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById(tooltipId);
  
  // Set canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const width = rect.width;
  const height = rect.height;
  
  // Chart margins - increase top margin for legend space
  const margin = { top: 80, right: 5, bottom: 60, left: 80 };  
  const chartWidth = width - margin.left - margin.right;
  const chartHeight = height - margin.top - margin.bottom;
  
  // Adjust margins for smaller screens
  if (width < 768) {
    margin.top = 70;  // More top space for legend on mobile
    margin.right = 2;   // Very minimal right margin
    margin.bottom = 40;  
    margin.left = 50;   
  }
  
  // Clear canvas
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  // Find max value for scaling
  const maxValue = Math.max(...chartData.datasets.flatMap(d => d.data));
  const scale = chartHeight / maxValue;
  
  // Draw axes only (no grid)
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  // Y-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  ctx.stroke();
  
  // X-axis
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Y-axis labels
  for (let i = 0; i <= 5; i++) {
    const y = margin.top + (chartHeight * i / 5);
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'right';
    const value = Math.round(maxValue * (5 - i) / 5);
    // Format numbers as k for thousands
    const formattedValue = value >= 1000 ? Math.round(value/1000) + 'k' : value.toString();
    ctx.fillText(formattedValue, margin.left - 10, y + 4);
  }
  
  // X-axis labels
  for (let i = 0; i < chartData.labels.length; i++) {
    const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
    ctx.fillStyle = '#888';
    ctx.font = '12px Manrope, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(chartData.labels[i], x, height - margin.bottom + 20);
  }
  
  // Draw data lines
  chartData.datasets.forEach((dataset, datasetIndex) => {
    ctx.strokeStyle = dataset.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    dataset.data.forEach((value, i) => {
      const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
      const y = margin.top + chartHeight - (value * scale);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    ctx.stroke();
    
    // Draw points
    ctx.fillStyle = dataset.color;
    dataset.data.forEach((value, i) => {
      const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
      const y = margin.top + chartHeight - (value * scale);
      
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();
    });
  });
  
  // Draw legend with better mobile positioning and multi-line support
  const legendStartY = margin.top - 50;  // Move legend further above chart
  let legendX = margin.left;
  let legendY = legendStartY;
  const isMobile = width < 768;
  const maxLegendWidth = chartWidth - 20; // Leave some margin
  
  chartData.datasets.forEach((dataset, i) => {
    const textWidth = ctx.measureText(dataset.label).width;
    const itemWidth = textWidth + 40; // Text width + spacing
    
    // Check if current item would overflow, if so move to next line
    if (legendX + itemWidth > margin.left + maxLegendWidth && i > 0) {
      legendX = margin.left;
      legendY += 25; // Move to next line
    }
    
    // Legend color box
    ctx.fillStyle = dataset.color;
    ctx.fillRect(legendX, legendY, 12, 12);
    
    // Legend text
    ctx.fillStyle = '#fff';
    ctx.font = isMobile ? '10px Manrope, sans-serif' : '12px Manrope, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(dataset.label, legendX + 18, legendY + 9);
    
    legendX += itemWidth;
  });
  
  // Mouse hover functionality
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Find closest data point with even larger detection area
    let closestDistance = Infinity;
    let closestPoint = null;
    
    chartData.datasets.forEach((dataset, datasetIndex) => {
      dataset.data.forEach((value, i) => {
        const x = margin.left + (chartWidth * i / (chartData.labels.length - 1));
        const y = margin.top + chartHeight - (value * scale);
        const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        
        // Much larger detection radius - 60 pixels
        if (distance < 60 && distance < closestDistance) {
          closestDistance = distance;
          const prevValue = i > 0 ? dataset.data[i-1] : dataset.data[i];
          const growthPercent = i > 0 ? (((value - prevValue) / prevValue) * 100).toFixed(1) : 0;
          
          closestPoint = {
            dataset: dataset.label,
            year: chartData.labels[i],
            value: value,
            formattedValue: value >= 1000 ? (value/1000).toFixed(0) + 'k' : value.toLocaleString(),
            growth: growthPercent,
            color: dataset.color,
            // Use actual mouse position for more accurate positioning
            x: e.clientX,
            y: e.clientY
          };
        }
      });
    });
    
    // Show tooltip if we found a point
    if (closestPoint) {
      tooltip.style.display = 'block';
      
      // Position relative to the chart container, not the entire page
      const containerRect = canvas.closest('.chart-container').getBoundingClientRect();
      const relativeX = closestPoint.x - containerRect.left;
      const relativeY = closestPoint.y - containerRect.top;
      
      // Smart positioning within chart boundaries
      const tooltipWidth = 200;
      const tooltipHeight = 120;
      let leftPos = relativeX - 15;
      let topPos = relativeY - 140;
      
      // Keep tooltip within chart container bounds
      if (leftPos + tooltipWidth > containerRect.width) {
        leftPos = containerRect.width - tooltipWidth - 10;
      }
      if (leftPos < 10) {
        leftPos = 10;
      }
      
      if (topPos < 10) {
        topPos = relativeY + 20; // Below cursor if needed
      }
      if (topPos + tooltipHeight > containerRect.height) {
        topPos = containerRect.height - tooltipHeight - 10;
      }
      
      tooltip.style.left = leftPos + 'px';
      tooltip.style.top = topPos + 'px';
      tooltip.innerHTML = `
        <div class="tooltip-platform" style="color: ${closestPoint.color};">
          <div class="tooltip-circle" style="background-color: ${closestPoint.color};"></div>
          ${closestPoint.dataset}
        </div>
        <div class="tooltip-value">${closestPoint.formattedValue}</div>
        <div class="tooltip-growth">+${closestPoint.growth}% vs previous year</div>
        <div class="tooltip-year">${closestPoint.year}</div>
      `;
      
      // Clear any existing timeout
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
    } else {
      // Longer delay before hiding to prevent flickering
      const timeoutKey = `${canvasId}TooltipTimeout`;
      if (window[timeoutKey]) {
        clearTimeout(window[timeoutKey]);
      }
      window[timeoutKey] = setTimeout(() => {
        tooltip.style.display = 'none';
      }, 300);
    }
  });
  
  // Only hide immediately when mouse leaves canvas completely
  canvas.addEventListener('mouseleave', () => {
    const timeoutKey = `${canvasId}TooltipTimeout`;
    if (window[timeoutKey]) {
      clearTimeout(window[timeoutKey]);
    }
    // Longer delay even on mouse leave
    window[timeoutKey] = setTimeout(() => {
      tooltip.style.display = 'none';
    }, 200);
  });
}

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const animatedElements = document.querySelectorAll('.fade-in, .slide-in-left, .slide-in-right, .scale-in');
  animatedElements.forEach(el => observer.observe(el));
  
  // Draw charts after a short delay to ensure canvas is ready
  setTimeout(() => {
    // First set of charts (Red Bow Music) - all three charts
    drawChart('growthChart', 'chartTooltip', chartData);
    drawRevenueChart('revenueChart', 'revenueTooltip', revenueData);
    drawPieChart('pieChart', 'pieTooltip', pieData);

    // Second set (repareo) - metrics, revenue chart, and efficiency line chart
    drawRevenueChart('revenueChart2', 'revenueTooltip2', revenueData2);
    drawEfficiencyChart('efficiencyChart', 'efficiencyTooltip');

    // ✅ Third section (Everjump) — both charts
    drawEfficiencyChart3();
    drawRevenueChart3();
  }, 100);

  // Redraw charts on window resize
  window.addEventListener('resize', () => {
    setTimeout(() => {
      drawChart('growthChart', 'chartTooltip', chartData);
      drawRevenueChart('revenueChart', 'revenueTooltip', revenueData);
      drawPieChart('pieChart', 'pieTooltip', pieData);

      drawRevenueChart('revenueChart2', 'revenueTooltip2', revenueData2);
      drawEfficiencyChart('efficiencyChart', 'efficiencyTooltip');

      // ✅ Third section (Everjump) — re-draw both on resize
      drawEfficiencyChart3();
      drawRevenueChart3();
    }, 100);
  });
});

</script>
  
</body>
</html>
